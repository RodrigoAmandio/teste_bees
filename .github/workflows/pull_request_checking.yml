name: Unit test

on: 
  pull_request:
    types:
      - opened
      - synchronize  

jobs: 
  check-formatting:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3 # GitHub Action used in workflows to check out your repository's code so subsequent steps in the workflow can access the files in it. It is like a download of the files.

      - name: Begin
        run: echo "Beginning to check code formatting"

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install black isort

      - name: Code Formatting
        run: |
          echo "Checking code formatting..."
          make check
  
  check-branch-name:
    needs: check-formatting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3 # Checks out your repository's code.

      - name: Verify Branch Name Format
        run: |
          # Determine the branch name to check based on the event type
          BRANCH_TO_CHECK=""
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            
          # For pull_request events, github.head_ref contains the actual source branch name
            BRANCH_TO_CHECK="${{ github.head_ref }}"
            echo "Checking branch name for Pull Request: $BRANCH_TO_CHECK"
          
            else
            # For push events, github.ref contains 'refs/heads/branch-name', so extract the branch name
            BRANCH_TO_CHECK=$(echo "${{ github.ref }}" | sed 's/refs\/heads\///')
            echo "Checking branch name for Push: $BRANCH_TO_CHECK"
          fi

          # This regex now only allows branch names that start with 'feature/'.
          if [[ ! "$BRANCH_TO_CHECK" =~ ^(main|develop|feature\/.*)$ ]]; then
            echo "Error: Branch name '$BRANCH_TO_CHECK' does not follow the required pattern."
            echo "Please ensure your branch name starts with 'feature/', main or develop (e.g., feature/add-new-feature)."
            
            # Outputs a tutorial about how to rename the branch
            echo "Rename your local branch: git branch -m <old-branch-name> <new-branch-name>"
            echo "Delete the old branch on the remote: git push origin --delete <old-branch-name>"
            echo "Push your new branch to the remote: git push -u origin <new-branch-name>"
            
            exit 1 # Fails the job if the pattern doesn't match
          else
            echo "Branch name '$BRANCH_TO_CHECK' follows the required pattern."
          fi
        shell: bash

  # Job to verify commit messages against a predefined pattern
  check-commit-pattern:
    runs-on: ubuntu-latest
    needs: check-branch-name # This job will only run if 'check-branch-name' succeeds
    steps:
      - name: Verify Commit Messages Format
        run: |
          echo "Checking commit messages for the current event..."

          # It allows for messages like "feat: description", "feat: " (with a space), or "feat:" (without a space).
          COMMIT_PATTERN="^(feat|fix|docs|chore|refactor|test|build|ci|perf|revert): .*$"

          # We use 'jq' to parse the JSON array of commits and extract ONLY THE FIRST LINE of each message.
          # The -r option outputs raw strings, not JSON strings.
          # The '|| true' prevents the step from failing if jq is not found or has no output.
          COMMIT_MESSAGES=$(echo '${{ toJSON(github.event.commits) }}' | jq -r '.[].message | split("\n")[0]' || true)

          NON_CONFORMING_COMMITS=""
          # Read each line (commit message subject) and check against the pattern
          while IFS= read -r line; do
            # Skip empty lines that might result from jq output
            if [[ -z "$line" ]]; then
              continue
            fi

            # Ignore commit messages that start with "Merge"
            if [[ "$line" =~ ^Merge ]]; then
              echo "Ignoring merge commit message: '$line'"
              continue
            fi

            # Check if the commit message line does NOT match the pattern
            if [[ ! "$line" =~ $COMMIT_PATTERN ]]; then
              NON_CONFORMING_COMMITS+="$line\n"
            fi
          done <<< "$COMMIT_MESSAGES"

          if [[ -n "$NON_CONFORMING_COMMITS" ]]; then
            echo "Error: One or more commit messages do not follow the required pattern."
            echo "Please ensure all non-merge commit messages adhere to a standard format (e.g., Conventional Commits)."
            echo "Example allowed patterns for non-merge commits:"
            echo "  feat: Your new feature description (or just 'feat:')"
            echo "  fix: Your bug fix description (or just 'fix:')"
            echo "  docs: Your documentation update (or just 'docs:')"
            echo "  chore: Routine maintenance task (or just 'chore:')"
            echo "  refactor: Code refactoring (or just 'refactor:')"
            echo "  test: New test case (or just 'test:')"
            echo "  build: Build system system changes (or just 'build:')"
            echo "  ci: CI configuration changes (or just 'ci:')"
            echo "  perf: Performance improvements (or just 'perf:')"
            echo "  revert: Revert a previous commit (or just 'revert:')"
            echo ""
            echo "Commit messages found in this push that do NOT conform (excluding merge commits):"
            echo -e "$NON_CONFORMING_COMMITS"
            
            # Outputs a tutorial about how to rebase the wrong commits
            echo "Run git rebase -i HEAD~N in your terminal. N is the number of commits to retrieve"
            echo "Change the word pick to reword (or r) next to the commit(s) whose message you want to change. Save and close the editor"
            echo "Run git push --force-with-lease origin <your-branch-name> in your terminal"
            exit 1 # Fails the job if any commit message doesn't match
          else
            echo "All commit messages follow the required pattern."
          fi
        shell: bash