name: Unit test

on: 
  push:     

jobs: 
  check-formatting:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3 # GitHub Action used in workflows to check out your repository's code so subsequent steps in the workflow can access the files in it. It is like a download of the files.

      - name: Begin
        run: echo "Beginning to check code formatting"

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install black isort

      - name: Code Formatting
        run: |
          echo "Checking code formatting..."
          make check
  
  check-branch-name:
    needs: check-formatting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3 # Checks out your repository's code.

      - name: Verify Branch Name Format
        run: |
          # Get the current branch name from the GitHub context
          # Branch refs in github.ref always start with refs/heads/
          BRANCH_NAME="${{ github.ref }}"
          echo "Checking branch name: $BRANCH_NAME"

          # This regex now only allows branch names that start with 'feature/'.
          if [[ ! "$BRANCH_NAME" =~ ^refs/heads/(main|develop|feature\/.*)$ ]]; then
            echo "Error: Branch name '$BRANCH_NAME' does not follow the required pattern."
            echo "Please ensure your branch name starts with 'feature/', main or develop (e.g., feature/add-new-feature)."
            
            # Outputs a tutorial about how to rename the branch
            echo "Rename your local branch: git branch -m <old-branch-name> <new-branch-name>"
            echo "Delete the old branch on the remote: git push origin --delete <old-branch-name>"
            echo "Push your new branch to the remote: git push -u origin <new-branch-name>"
            
            exit 1 # Fails the job if the pattern doesn't match
          else
            echo "Branch name '$BRANCH_NAME' follows the required pattern."
          fi
        shell: bash

  # Job to verify commit messages against a predefined pattern
  check-commit-pattern:
    runs-on: ubuntu-latest
    needs: check-branch-name # This job will only run if 'check-branch-name' succeeds
    steps:
      - name: Verify Commit Messages Format
        run: |
          echo "Checking commit messages for the current push..."

          # Example: "feat: Add user authentication" or "fix: Resolve critical bug"
          COMMIT_PATTERN="^(feat|fix|docs|chore|refactor|test|build|ci|perf|revert): .+|Merge pull request #\\d+ from .+\/.+$"

          # Get the list of commit messages from the GitHub event payload.
          # We use 'jq' to parse the JSON array of commits and extract each message.
          # The -r option outputs raw strings, not JSON strings.
          # The '|| true' prevents the step from failing if jq is not found or has no output.
          COMMIT_MESSAGES=$(echo '${{ toJSON(github.event.commits) }}' | jq -r '.[].message' || true)

          NON_CONFORMING_COMMITS=""
          # Read each line (commit message) and check against the pattern
          while IFS= read -r line; do
            # Skip empty lines that might result from jq output or multi-line commit messages
            if [[ -z "$line" ]]; then
              continue
            fi
            # Check if the commit message line does NOT match the pattern
            if [[ ! "$line" =~ $COMMIT_PATTERN ]]; then
              NON_CONFORMING_COMMITS+="$line\n"
            fi
          done <<< "$COMMIT_MESSAGES"

          if [[ -n "$NON_CONFORMING_COMMITS" ]]; then
            echo "Error: One or more commit messages do not follow the required pattern."
            echo "Please ensure all commit messages adhere to a standard format (e.g., Conventional Commits)."
            echo "Example allowed patterns:"
            echo "  feat: Your new feature description"
            echo "  fix: Your bug fix description"
            echo "  docs: Your documentation update"
            echo "  chore: Routine maintenance task"
            echo "  refactor: Code refactoring"
            echo "  test: New test case"
            echo "  build: Build system system changes"
            echo "  ci: CI configuration changes"
            echo "  perf: Performance improvements"
            echo "  revert: Revert a previous commit"
            echo ""
            echo "Commit messages found in this push that do NOT conform:"
            echo -e "$NON_CONFORMING_COMMITS" # -e to interpret newlines
            
            # Outputs a tutorial about how to rebase the wrong commits
            echo "Run git rebase -i HEAD~N in your terminal. N is the number of commits to retrieve"
            echo "Change the word pick to reword (or r) next to the commit(s) whose message you want to change. Save and close the editor"
            echo "Run git push --force-with-lease origin <your-branch-name> in your terminal"
            exit 1 # Fails the job if any commit message doesn't match
          else
            echo "All commit messages follow the required pattern."
          fi
        shell: bash